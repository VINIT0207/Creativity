<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EchoPuzzles Pro | Advanced Interactive Puzzle Platform</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
/* Modern CSS Variables */
:root {
  --bg-1: #071018;
  --bg-2: #02121a;
  --panel: rgba(255, 255, 255, 0.03);
  --accent: #00e6c3; /* Teal */
  --accent-2: #2bdcff; /* Cyan */
  --accent-pink: #ff7ab6; /* Added for level 1 sequence */
  --accent-yellow: #ffd166; /* Added for level 1 sequence, also warning */
  --accent-dark: #009e86;
  --accent-hover: #00ffd9;
  --muted: #8aa;
  --glass: rgba(255, 255, 255, 0.03);
  --success: #00c896;
  --error: #ff6b6b;
  --warning: #ffd166;
  --text: #dfe;
  --text-secondary: #a8c2c2;
  --card-bg: rgba(2, 30, 36, 0.6);
  --border: rgba(255, 255, 255, 0.06);
  --border-light: rgba(0, 230, 195, 0.15);
  --shadow: 0 12px 30px rgba(0, 0, 0, 0.65);
  --transition: all 0.3s ease;
}

/* Modern Reset & Global Styles */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  height: 100%;
  margin: 0;
  font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  color: var(--text);
  background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
  line-height: 1.6;
  overflow-x: hidden;
}

body {
  background-attachment: fixed;
  background-size: cover;
  background-position: center;
  position: relative;
}

body::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: 
    radial-gradient(circle at 15% 50%, rgba(0, 230, 195, 0.08) 0%, transparent 20%),
    radial-gradient(circle at 85% 30%, rgba(43, 220, 255, 0.05) 0%, transparent 20%);
  pointer-events: none;
  z-index: -1;
}

/* Layout */
.container {
  max-width: 1400px;
  margin: 0 auto;
  padding: 0 20px;
}

header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 18px 26px;
  border-bottom: 1px solid var(--border);
  background: rgba(4, 18, 24, 0.8);
  backdrop-filter: blur(10px);
  position: sticky;
  top: 0;
  z-index: 100;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
}

main {
  display: grid;
  grid-template-columns: 320px 1fr;
  gap: 22px;
  padding: 25px;
  min-height: calc(100vh - 85px);
}

/* Branding */
.brand {
  display: flex;
  gap: 14px;
  align-items: center;
  transition: var(--transition);
}

.brand:hover {
  transform: translateY(-2px);
}

.logo {
  width: 56px;
  height: 56px;
  border-radius: 16px;
  background: linear-gradient(135deg, var(--accent), var(--accent-2));
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  color: #022;
  box-shadow: var(--shadow);
  font-size: 24px;
  transition: var(--transition);
}

.logo:hover {
  transform: rotate(8deg) scale(1.05);
}

.title {
  font-size: 22px;
  font-weight: 800;
  letter-spacing: -0.5px;
  background: linear-gradient(to right, var(--accent), var(--accent-2));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}

.subtitle {
  font-size: 13px;
  color: var(--muted);
  max-width: 300px;
}

/* Navigation */
nav {
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
  padding: 20px;
  border-radius: 16px;
  min-height: 600px;
  border: 1px solid var(--border);
  backdrop-filter: blur(8px);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  display: flex;
  flex-direction: column;
}

nav h3 {
  font-size: 16px;
  font-weight: 700;
  margin-bottom: 16px;
  color: var(--accent);
  display: flex;
  align-items: center;
  gap: 8px;
}

.levels {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.level-btn {
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent);
  padding: 14px 16px;
  border-radius: 12px;
  border: 1px solid var(--border);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  transition: var(--transition);
  position: relative;
  overflow: hidden;
}

.level-btn:not(.locked):hover {
  transform: translateY(-3px);
  border-color: var(--border-light);
  box-shadow: 0 8px 20px rgba(0, 230, 195, 0.1);
}

.level-btn.locked {
  opacity: 0.4;
  filter: grayscale(0.5);
  cursor: not-allowed;
}

.level-btn.playing {
  box-shadow: 0 8px 30px rgba(0, 230, 195, 0.15);
  border: 1px solid rgba(0, 230, 195, 0.25);
  background: linear-gradient(180deg, rgba(0, 230, 195, 0.1), transparent);
  animation: pulse 2s infinite;
}

.level-btn .badge {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 20px;
  padding: 4px 10px;
  font-size: 12px;
  font-weight: 600;
}

.level-btn .stars {
  color: var(--warning);
  font-size: 12px;
  margin-left: 5px;
}

.level-btn .meta {
  font-size: 12px;
  color: var(--muted);
  display: flex;
  align-items: center;
  gap: 8px;
}

.level-btn .lock-icon {
  font-size: 14px;
  margin-left: 5px;
}

/* Content Area */
.content {
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent);
  padding: 22px;
  border-radius: 16px;
  min-height: 600px;
  border: 1px solid var(--border);
  backdrop-filter: blur(8px);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  position: relative;
  display: flex;
  flex-direction: column;
}

.panel-title {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  margin-bottom: 18px;
  gap: 20px;
}

.panel-title h2 {
  font-weight: 800;
  font-size: 24px;
  margin-bottom: 8px;
  letter-spacing: -0.5px;
  background: linear-gradient(to right, var(--accent), var(--accent-2));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}

.desc {
  color: var(--text-secondary);
  font-size: 14px;
  max-width: 700px;
  line-height: 1.6;
}

.level-meta {
  display: flex;
  align-items: center;
  gap: 12px;
  background: rgba(0, 0, 0, 0.2);
  padding: 8px 14px;
  border-radius: 12px;
  font-size: 14px;
  color: var(--text-secondary);
  min-width: 180px;
}

.level-meta i {
  color: var(--accent);
  font-size: 18px;
}

/* Game Area */
.game-area {
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), rgba(255, 255, 255, 0.005));
  height: 480px;
  border-radius: 12px;
  padding: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  border: 1px solid var(--border);
  margin-top: 10px;
  position: relative;
  overflow: hidden;
}

.game-area::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 4px;
  background: linear-gradient(90deg, var(--accent), var(--accent-2));
  opacity: 0.3;
}

.game-controls {
  display: flex;
  justify-content: space-between;
  width: 100%;
  margin-bottom: 15px;
  gap: 12px;
}

.game-stats {
  display: flex;
  gap: 15px;
}

.stat-box {
  background: rgba(0, 0, 0, 0.25);
  padding: 8px 15px;
  border-radius: 10px;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
  border: 1px solid var(--border);
}

.stat-box i {
  color: var(--accent);
}

/* HUD */
.hud {
  background: rgba(1, 20, 25, 0.7);
  padding: 18px;
  border-radius: 12px;
  color: var(--muted);
  font-size: 14px;
  border: 1px solid var(--border);
  width: 240px;
  backdrop-filter: blur(6px);
  margin-top: auto;
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
}

.hud h3 {
  font-weight: 700;
  margin-bottom: 12px;
  color: var(--accent);
  display: flex;
  align-items: center;
  gap: 8px;
}

.hud-section {
  margin-bottom: 16px;
}

#unlocked {
  color: var(--text-secondary);
  margin-top: 6px;
  line-height: 1.5;
  min-height: 40px;
}

/* Progress bar */
.progress {
  height: 10px;
  background: rgba(255, 255, 255, 0.03);
  border-radius: 6px;
  overflow: hidden;
  margin-top: 8px;
  position: relative;
}

.progress > i {
  display: block;
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent-2));
  width: 0%;
  transition: width 0.8s cubic-bezier(0.22, 0.61, 0.36, 1);
  position: relative;
  overflow: hidden;
}

.progress > i::after {
  content: "";
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  animation: progressShine 2s infinite;
}

/* Buttons */
button {
  transition: var(--transition);
  cursor: pointer;
  border: none;
  font-weight: 600;
  font-family: 'Inter', sans-serif;
  outline: none;
}

button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

button:active {
  transform: scale(0.96);
}

.primary {
  background: var(--accent);
  padding: 12px 22px;
  border-radius: 10px;
  color: #022;
  font-weight: 700;
  box-shadow: 0 6px 20px rgba(0, 230, 195, 0.3);
  display: inline-flex;
  align-items: center;
  gap: 8px;
  font-size: 15px;
}

.primary:hover {
  background: var(--accent-hover);
  box-shadow: 0 8px 25px rgba(0, 230, 195, 0.4);
  transform: translateY(-2px);
}

.btn-ghost {
  background: transparent;
  border: 1px solid var(--border);
  padding: 10px 16px;
  border-radius: 10px;
  color: var(--muted);
  display: inline-flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
}

.btn-ghost:hover {
  border-color: var(--border-light);
  color: var(--accent);
  background: rgba(0, 230, 195, 0.05);
}

/* Achievements */
.achievements {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-top: 8px;
}

.badge {
  padding: 8px 14px;
  border-radius: 10px;
  background: linear-gradient(180deg, #001f1a, rgba(255, 255, 255, 0.02));
  border: 1px solid var(--border);
  font-size: 13px;
  color: var(--text);
  display: flex;
  align-items: center;
  gap: 8px;
  transition: var(--transition);
}

.badge:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 15px rgba(0, 230, 195, 0.1);
  border-color: var(--border-light);
}

.badge i {
  color: var(--warning);
}

/* Popups & Message Box */
.popup {
  position: fixed;
  left: 50%;
  top: 14%;
  transform: translateX(-50%);
  background: linear-gradient(180deg, #062226, #002724);
  padding: 24px;
  border-radius: 16px;
  border: 1px solid var(--border);
  box-shadow: 0 30px 90px rgba(0, 0, 0, 0.6);
  display: none;
  color: #cff;
  z-index: 100;
  width: 90%;
  max-width: 500px;
  backdrop-filter: blur(10px);
  animation: popIn 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
}

.popup.show {
  display: block;
}

.popup h2 {
  font-weight: 800;
  font-size: 22px;
  margin-bottom: 10px;
  color: var(--accent);
  display: flex;
  align-items: center;
  gap: 10px;
}

.popup p {
  margin: 15px 0;
  line-height: 1.6;
  color: var(--text-secondary);
}

.popup-buttons {
  display: flex;
  justify-content: flex-end;
  margin-top: 20px;
  gap: 12px;
}

/* Puzzle elements */
.grid {
  display: grid;
  gap: 10px;
  width: 100%; /* Ensure grid takes full width of its container */
  max-width: 400px; /* Optional: limit max width for larger screens */
  margin: 20px auto; /* Center the grid */
}

.tile {
  background: var(--card-bg);
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px;
  color: #cfe;
  font-weight: 700;
  cursor: pointer;
  transition: var(--transition);
  border: 1px solid var(--border);
  user-select: none; /* Prevent text selection */
}

.tile:hover:not(.disabled):not(.correct):not(.matched) {
  transform: scale(1.03);
  border-color: var(--border-light);
}

.tile.correct {
  background: var(--success);
  color: #fff;
  border-color: var(--success);
  pointer-events: none; /* Disable clicking once correct */
}

.tile.incorrect {
  background: var(--error);
  color: #fff;
  border-color: var(--error);
  animation: shake 0.5s;
}

.tile.disabled {
  pointer-events: none; /* Disable interaction */
  opacity: 0.7;
}

.hint-box {
  margin-top: 15px;
  background: rgba(255, 255, 255, 0.02);
  padding: 14px;
  border-radius: 10px;
  color: var(--muted);
  border: 1px solid var(--border);
  font-size: 14px;
  line-height: 1.6;
}

.hint-box strong {
  color: var(--accent);
}

.level-footer {
  display: flex;
  gap: 12px;
  align-items: center;
  margin-top: 20px;
  flex-wrap: wrap;
}

/* Animations */
@keyframes pulse {
  0% { transform: scale(1); box-shadow: 0 8px 30px rgba(0, 230, 195, 0.15); }
  50% { transform: scale(1.02); box-shadow: 0 8px 40px rgba(0, 230, 195, 0.25); }
  100% { transform: scale(1); box-shadow: 0 8px 30px rgba(0, 230, 195, 0.15); }
}

@keyframes popIn {
  0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
  100% { opacity: 1; transform: translateX(-50%) translateY(0); }
}

@keyframes progressShine {
  0% { left: -100%; }
  100% { left: 100%; }
}

@keyframes float {
  0% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
  100% { transform: translateY(0); }
}

@keyframes shake {
  0% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  50% { transform: translateX(5px); }
  75% { transform: translateX(-5px); }
  100% { transform: translateX(0); }
}

/* Responsive */
@media (max-width: 1100px) {
  main {
    grid-template-columns: 1fr;
    padding: 15px;
  }
  
  nav {
    order: 2;
  }
  
  .hud {
    position: static;
    margin-top: 20px;
    width: 100%;
  }
}

@media (max-width: 768px) {
  header {
    flex-direction: column;
    align-items: flex-start;
    gap: 15px;
    padding: 15px;
  }
  
  .brand {
    width: 100%;
  }
  
  .game-controls {
    flex-direction: column;
  }
  
  .game-stats {
    flex-wrap: wrap;
  }
  
  .level-meta {
    margin-top: 15px;
  }
}

/* Custom Elements */
.welcome-screen {
  text-align: center;
  max-width: 700px;
  padding: 20px;
}

.welcome-screen h1 {
  font-size: 36px;
  font-weight: 800;
  margin-bottom: 15px;
  background: linear-gradient(to right, var(--accent), var(--accent-2));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  line-height: 1.2;
}

.welcome-screen p {
  color: var(--text-secondary);
  font-size: 18px;
  margin-bottom: 25px;
  line-height: 1.6;
}

.features {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 20px;
  margin: 30px 0;
}

.feature {
  background: var(--card-bg);
  border-radius: 12px;
  padding: 20px;
  border: 1px solid var(--border);
  transition: var(--transition);
}

.feature:hover {
  transform: translateY(-5px);
  border-color: var(--border-light);
}

.feature i {
  font-size: 32px;
  color: var(--accent);
  margin-bottom: 15px;
}

.feature h3 {
  font-size: 18px;
  margin-bottom: 10px;
  color: var(--text);
}

.feature p {
  font-size: 14px;
  color: var(--text-secondary);
}

.hero-btns {
  display: flex;
  gap: 15px;
  justify-content: center;
  margin-top: 20px;
  flex-wrap: wrap;
}

.divider {
  height: 1px;
  background: var(--border);
  margin: 20px 0;
}

/* Level-specific styles */
/* Memory Card styles */
.memory-grid {
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(4, 1fr);
  width: min(100%, 400px); /* Max width 400px */
  aspect-ratio: 1 / 1; /* Keep it square */
}

.memory-card {
  width: 100%;
  height: 100%;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: min(8vw, 28px); /* Responsive font size */
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid var(--border);
  transition: transform 0.3s ease, background 0.3s ease, border-color 0.3s ease;
  transform-style: preserve-3d; /* For flip animation */
  position: relative;
  cursor: pointer;
  user-select: none;
}

.memory-card.flipped {
  transform: rotateY(180deg);
  background: rgba(0, 230, 195, 0.08); /* Flipped color */
}

.memory-card.matched {
  background: var(--success);
  border-color: var(--success);
  color: #fff;
  pointer-events: none;
  opacity: 0.8;
  animation: matched-pop 0.3s ease-out;
}

.memory-card .card-inner {
  position: absolute;
  width: 100%;
  height: 100%;
  text-align: center;
  transition: transform 0.6s;
  transform-style: preserve-3d;
}

.memory-card.flipped .card-inner {
  transform: rotateY(180deg);
}

.memory-card .card-front, .memory-card .card-back {
  position: absolute;
  width: 100%;
  height: 100%;
  -webkit-backface-visibility: hidden; /* Safari */
  backface-visibility: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
}

.memory-card .card-front {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid var(--border);
}

.memory-card .card-back {
  background: rgba(0, 230, 195, 0.08); /* Flipped color */
  border: 1px solid rgba(0, 230, 195, 0.2);
  transform: rotateY(180deg);
}

@keyframes matched-pop {
  0% { transform: scale(0.8); opacity: 0.5; }
  100% { transform: scale(1); opacity: 0.8; }
}


/* Slider Puzzle styles */
.slider-grid {
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  width: min(100%, 310px); /* Adjust based on tile size + gap */
  aspect-ratio: 1 / 1;
}

.slider-piece {
  width: 100%; /* Fill grid cell */
  height: 100%; /* Fill grid cell */
  background: linear-gradient(180deg, #023 0%, #045 100%);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: min(8vw, 24px); /* Responsive font size */
  font-weight: 700;
  border: 1px solid var(--border);
  transition: transform 0.3s ease, background 0.3s ease; /* For smooth movement */
  cursor: pointer;
  user-select: none;
}

.slider-piece.empty {
  background: transparent;
  border: 1px dashed var(--muted);
  cursor: default;
}

.slider-piece.moving {
  transform: scale(0.98);
  opacity: 0.9;
}

/* Trace Echo styles */
.trace-grid {
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  width: min(100%, 300px);
  aspect-ratio: 1 / 1;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: rgba(0,0,0,0.2);
  padding: 5px; /* Inner padding for nodes */
}

.node {
  width: 100%;
  height: 100%;
  background: var(--card-bg);
  border-radius: 50%; /* Make them circular */
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2em;
  color: var(--text);
  border: 2px solid var(--border);
  transition: background 0.2s ease, border-color 0.2s ease;
  cursor: pointer;
}

.node.active {
  background: var(--accent);
  border-color: var(--accent-hover);
  box-shadow: 0 0 15px var(--accent);
}

.node.visited {
  background: var(--accent-2);
  border-color: var(--accent-hover);
  opacity: 0.7;
}

.line-svg-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none; /* Allows clicks to pass through to nodes */
  z-index: 1; /* Above nodes, below feedback */
}

.trace-line {
  stroke: var(--accent-2);
  stroke-width: 4;
  fill: none;
  stroke-linecap: round;
  stroke-linejoin: round;
  transition: stroke 0.3s ease;
}

.trace-line.temp {
  stroke: rgba(43, 220, 255, 0.5);
  stroke-dasharray: 5 5;
}

/* Maze styles */
.maze-grid {
    grid-template-columns: repeat(5, 1fr); /* Example 5x5 maze */
    grid-template-rows: repeat(5, 1fr);
    width: min(100%, 350px);
    aspect-ratio: 1 / 1;
    border: 2px solid var(--border-light);
    background-color: #030a10;
}

.maze-cell {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5em; /* For player/exit icons */
    color: var(--text);
    background-color: #02121a; /* Path */
    border: 1px solid rgba(255, 255, 255, 0.05);
}

.maze-cell.wall {
    background-color: #071018; /* Wall */
    box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
}

.maze-cell.player {
    background-color: var(--accent);
    color: #022;
    font-weight: bold;
    animation: pulse-player 1s infinite alternate;
}
.maze-cell.exit {
    background-color: var(--success);
    color: #022;
    font-weight: bold;
}
.maze-cell.visited-path {
    background-color: rgba(0, 230, 195, 0.05); /* Faint green for visited paths */
}
.maze-cell.pinged {
    background-color: rgba(43, 220, 255, 0.1); /* Sonar ping effect */
}

@keyframes pulse-player {
    from { transform: scale(1); }
    to { transform: scale(1.05); }
}

.maze-controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 20px;
}
.maze-controls .direction-buttons {
    display: grid;
    grid-template-areas: ". up ." "left center right" ". down .";
    gap: 8px;
    width: 180px; /* fixed width for buttons */
    margin: 0 auto;
}
.maze-controls button {
    padding: 12px 15px;
    font-size: 1em;
}
.maze-controls button.up { grid-area: up; }
.maze-controls button.down { grid-area: down; }
.maze-controls button.left { grid-area: left; }
.maze-controls button.right { grid-area: right; }
.maze-controls button.center { grid-area: center; } /* For ping */

.maze-info {
    margin-top: 15px;
    font-size: 0.9em;
    color: var(--text-secondary);
}
.maze-info strong {
    color: var(--accent);
}

/* Caesar Clue styles */
.cipher-container {
    text-align: center;
    padding: 20px;
}
.encrypted-message {
    font-family: 'monospace';
    font-size: 1.5em;
    padding: 20px;
    background: rgba(0,0,0,0.3);
    border-radius: 10px;
    border: 1px solid var(--border);
    margin: 20px auto;
    max-width: 600px;
    word-break: break-all;
    user-select: text;
}
.cipher-controls {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-top: 20px;
    max-width: 400px;
    margin-left: auto;
    margin-right: auto;
}
.cipher-controls label {
    display: flex;
    align-items: center;
    gap: 10px;
    color: var(--text-secondary);
    font-size: 0.95em;
}
.cipher-controls input[type="number"] {
    flex-grow: 1;
    padding: 10px 15px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background-color: rgba(255,255,255,0.05);
    color: var(--text);
    font-size: 1em;
    outline: none;
    appearance: textfield; /* Hide arrows on number input */
    -moz-appearance: textfield;
}
.cipher-controls input[type="number"]::-webkit-outer-spin-button,
.cipher-controls input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}
.decrypted-output {
    margin-top: 20px;
    font-family: 'monospace';
    font-size: 1.3em;
    color: var(--accent-2);
    min-height: 1.5em;
    word-break: break-all;
}

/* Echo Math styles */
.math-container {
    text-align: center;
    padding: 20px;
}
.math-target {
    font-size: 2.2em;
    font-weight: bold;
    color: var(--accent);
    margin-bottom: 20px;
}
.math-numbers {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-bottom: 25px;
    flex-wrap: wrap;
}
.math-number-tile {
    background: var(--card-bg);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px 20px;
    font-size: 1.4em;
    font-weight: 700;
    color: var(--text);
}
.math-input-group {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-bottom: 25px;
    flex-wrap: wrap;
}
.math-input-group input[type="text"] {
    flex-grow: 1;
    max-width: 300px;
    padding: 12px 15px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background-color: rgba(255,255,255,0.05);
    color: var(--text);
    font-size: 1.1em;
    outline: none;
    text-align: center;
}
.math-result {
    font-size: 1.5em;
    font-weight: bold;
    min-height: 1.5em;
}

/* Assemble Echo styles */
.assemble-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    padding: 20px;
    width: min(100%, 400px);
}
.assemble-board {
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* Example 2x2 */
    grid-template-rows: repeat(2, 1fr);
    width: 100%;
    aspect-ratio: 1 / 1;
    border: 2px dashed var(--border-light);
    border-radius: 12px;
    padding: 5px;
    position: relative;
    background-color: #030a10;
}
.target-zone {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(0, 230, 195, 0.05);
    border: 1px dashed rgba(0, 230, 195, 0.3);
    border-radius: 8px;
}
.puzzle-piece {
    position: absolute; /* Will be positioned by JS */
    width: 100px; /* Fixed size for pieces */
    height: 100px;
    background: linear-gradient(135deg, #2bdcff, #00e6c3); /* Matching target colors */
    border: 2px solid var(--accent-hover);
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.8em;
    font-weight: bold;
    color: #022;
    cursor: grab;
    z-index: 10;
    box-shadow: 0 5px 15px rgba(0,0,0,0.4);
    transition: transform 0.1s ease; /* For smooth dragging */
}
.puzzle-piece:active {
    cursor: grabbing;
}
.puzzle-piece.placed {
    cursor: default;
    box-shadow: 0 0 10px var(--success);
    background: var(--success); /* Change color when correctly placed */
    z-index: 5; /* Lower z-index once placed */
}

/* Pulse Level Styles */
.pulse-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    gap: 20px;
}
.pulse-circle-container {
    position: relative;
    width: min(100%, 250px);
    height: min(100%, 250px);
    border: 3px solid var(--border);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(0,0,0,0.2);
    box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
}
.pulse-indicator {
    position: absolute;
    width: 25px;
    height: 25px;
    background-color: var(--accent);
    border-radius: 50%;
    transform-origin: 125px 125px; /* Center of the circle */
    top: -12.5px; /* Half of height to center it on the border */
    left: calc(50% - 12.5px); /* Half of width to center it on the border */
    transition: transform linear; /* For smooth rotation */
}
.pulse-zone {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 30px solid transparent; /* Width of cone base */
    border-right: 30px solid transparent;
    border-bottom: 60px solid rgba(0, 230, 195, 0.4); /* Green zone color */
    transform-origin: bottom center;
    filter: blur(2px);
    z-index: 0;
}
.pulse-info {
    font-size: 1.1em;
    color: var(--text-secondary);
}

input[type="text"], input[type="number"] {
    padding: 10px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background-color: rgba(255, 255, 255, 0.05);
    color: var(--text);
    font-size: 1em;
    outline: none;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
}
input[type="text"]:focus, input[type="number"]:focus {
    border-color: var(--accent);
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3), 0 0 8px rgba(0, 230, 195, 0.5);
}
</style>
</head>
<body>
<header>
  <div class="container">
    <div class="brand">
      <div class="logo floating">EP</div>
      <div>
        <div class="title">EchoPuzzles Pro</div>
        <div class="subtitle">An advanced interactive puzzle platform with achievements, progression, and hidden content</div>
      </div>
    </div>
    <div class="meta small">Cloud Sync â€¢ 10 Challenging Levels â€¢ Adaptive Difficulty</div>
  </div>
</header>

<main>
  <nav>
    <h3><i class="fas fa-layer-group"></i> Puzzle Levels</h3>
    <div class="levels" id="levelsList"></div>

    <div class="divider"></div>

    <h3><i class="fas fa-trophy"></i> Achievements</h3>
    <div id="achList" class="achievements"></div>

    <div class="hint-box" style="margin-top: auto;">
      <strong><i class="fas fa-lightbulb"></i> Pro Tip:</strong> Use hints strategically - they reduce your score but help when stuck. Complete levels quickly for bonus points!
    </div>
  </nav>

  <section class="content">
    <div class="panel-title">
      <div>
        <h2 id="levelTitle">Welcome to EchoPuzzles Pro</h2>
        <div class="desc" id="levelDesc">Select a level to begin your puzzle journey. Each level offers unique challenges and rewards.</div>
      </div>
      <div class="level-meta">
        <i class="fas fa-map-marker-alt"></i>
        Level <span id="curLevel">-</span> of 10
      </div>
    </div>

    <div class="game-area" id="gameArea">
      <div class="welcome-screen">
        <h1>Unlock Your Puzzle-Solving Potential</h1>
        <p>EchoPuzzles Pro is an advanced puzzle platform with progressive challenges, achievements, and adaptive difficulty.</p>
        
        <div class="features">
          <div class="feature floating delay-1">
            <i class="fas fa-puzzle-piece"></i>
            <h3>10 Unique Levels</h3>
            <p>Diverse puzzle types with increasing complexity</p>
          </div>
          <div class="feature floating delay-2">
            <i class="fas fa-trophy"></i>
            <h3>Achievements</h3>
            <p>Unlock badges and rewards for your progress</p>
          </div>
          <div class="feature floating">
            <i class="fas fa-chart-line"></i>
            <h3>Progression</h3>
            <p>Track your scores and improve over time</p>
          </div>
        </div>
        
        <div class="hero-btns">
          <button class="primary" id="startBtn">
            <i class="fas fa-play"></i> Start Level 1
          </button>
          <button class="btn-ghost">
            <i class="fas fa-book"></i> View Tutorial
          </button>
        </div>
      </div>
    </div>

    <div class="hud">
      <h3><i class="fas fa-gamepad"></i> Game Status</h3>
      <div class="hud-section">
        <div>Current Status:</div>
        <div id="statusText">Ready to Play</div>
      </div>
      
      <div class="hud-section">
        <div>Unlocked Content:</div>
        <div id="unlocked">Starter Content</div>
      </div>
      
      <div class="hud-section">
        <div>Overall Progress:</div>
        <div class="progress"><i id="scoreBar" style="width:0%"></i></div>
      </div>
    </div>
  </section>
</main>

<!-- Unified Popup/MessageBox -->
<div class="popup" id="messageBox">
  <h2 id="messageBoxTitle"><i class="fas fa-info-circle"></i> Message</h2>
  <div id="messageBoxText" style="margin-top:8px;color:#cfe">This is a general message.</div>
  <div class="popup-buttons">
    <button class="btn-ghost" id="messageBoxShare" style="display:none;">
      <i class="fas fa-share-alt"></i> Share
    </button>
    <button class="primary" id="messageBoxOk">
      <i class="fas fa-check"></i> Ok
    </button>
  </div>
</div>

<script>
/* Enhanced EchoPuzzles Pro - JavaScript */
const NUM_LEVELS = 10;
const STORAGE_KEY = 'echopuzzles_pro_v1';

// State management with enhanced features
let state = loadState();
let currentLevel = null;
let sessionScore = 0;
let gameTimer = null;
let timerValue = 0;

// Level definitions with enhanced descriptions
const levels = {
  1: {
    meta: 'Sequence Mastery',
    title: 'First Steps',
    desc: 'Click the colored buttons in the correct secret order. Pay attention to the visual cues in the interface.',
    hint: 'The sequence follows the gradient colors of our logo: teal, cyan, pink, then yellow.',
    difficulty: 'â˜…â˜†â˜†'
  },
  2: {
    meta: 'Memory Challenge',
    title: 'Echo Pairs',
    desc: 'Find all matching pairs by flipping cards two at a time. Your memory will be tested!',
    hint: 'Focus on memorizing positions of high-value symbols first. Try to find patterns in symbol locations.',
    difficulty: 'â˜…â˜…â˜†'
  },
  3: {
    meta: 'Spatial Reasoning',
    title: 'Slide Shift',
    desc: 'Reassemble the puzzle by sliding tiles into the empty space. Strategy beats speed here.',
    hint: 'Solve row by row. Complete the top row first, then middle, then bottom. Keep the empty space strategically positioned.',
    difficulty: 'â˜…â˜…â˜†'
  },
  4: {
    meta: 'Pattern Recognition',
    title: 'Trace Echo',
    desc: 'Draw the correct pattern through the nodes. Precision and pattern recognition are key.',
    hint: 'The pattern forms a diagonal cross starting from top-left to bottom-right, then top-right to bottom-left.',
    difficulty: 'â˜…â˜…â˜…'
  },
  5: {
    meta: 'Navigation',
    title: 'Silent Maze',
    desc: 'Navigate to the exit using limited sonar pings. Use your pings wisely!',
    hint: 'The exit is in the bottom right corner. Use pings at intersections to minimize wrong turns.',
    difficulty: 'â˜…â˜…â˜†'
  },
  6: {
    meta: 'Cryptography',
    title: 'Caesar Clue',
    desc: 'Decode the encrypted message using a Caesar cipher. Shift value unknown.',
    hint: 'Common shifts are 3 (ROT3) or 13 (ROT13). Try both if you get stuck.',
    difficulty: 'â˜…â˜…â˜…'
  },
  7: {
    meta: 'Mathematical Logic',
    title: 'Echo Math',
    desc: 'Use the given numbers to form the target value with basic arithmetic operations.',
    hint: 'Remember order of operations. Division can create fractions that help reach the target.',
    difficulty: 'â˜…â˜…â˜…'
  },
  8: {
    meta: 'Spatial Assembly',
    title: 'Assemble Echo',
    desc: 'Drag pieces to their targets to complete the puzzle. Precision matters.',
    hint: 'Look for color gradients that match the target areas. Pieces can be rotated by dragging corners.',
    difficulty: 'â˜…â˜…â˜†'
  },
  9: {
    meta: 'Reflex Training',
    title: 'Pulse',
    desc: 'Click when the indicator is in the green zone. Timing is everything!',
    hint: 'The green zone is at the top of the circle. Watch the speed - it changes after mistakes.',
    difficulty: 'â˜…â˜…â˜†'
  },
  10: {
    meta: 'Grand Finale',
    title: 'Full Echo',
    desc: 'Combine knowledge from previous puzzles to solve the ultimate challenge.',
    hint: 'The solution combines elements from Level 6 and Level 7. First, decrypt the message using a Caesar cipher, then solve the math problem it reveals.',
    difficulty: 'â˜…â˜…â˜…â˜…'
  }
};

/* ----------------------------- Helpers ------------------------------ */
function $(sel) { return document.querySelector(sel); }
function $create(tag, props) { 
  const el = document.createElement(tag); 
  if(props) {
    for (const key in props) {
      if (key === 'dataset') {
        // Handle dataset properties separately
        for (const dataKey in props.dataset) {
          el.dataset[dataKey] = props.dataset[dataKey];
        }
      } else {
        el[key] = props[key];
      }
    }
  }
  return el; 
}

// Enhanced state management
function saveState() { 
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); 
}

function loadState() { 
  try { 
    const s = JSON.parse(localStorage.getItem(STORAGE_KEY)); 
    if(s) return s; 
  } catch(e) {} 
  
  return { 
    unlocked: [1], 
    completed: [], 
    achievements: ['Welcome!'], 
    hintsUsed: {}, 
    scores: {},
    bestTimes: {}
  }; 
}

function percentClamp(v) { return Math.max(0, Math.min(100, v)); }

// Enhanced message box (replaces previous showPopup and alert)
// type: 'achievement', 'hint', 'info'
function showMessageBox(title, text, type = 'info') { 
  const messageBox = $('#messageBox');
  const messageBoxTitleEl = $('#messageBoxTitle');
  const messageBoxTextEl = $('#messageBoxText');
  const messageBoxOkBtn = $('#messageBoxOk');
  const messageBoxShareBtn = $('#messageBoxShare');

  messageBoxTitleEl.innerHTML = ''; // Clear existing icon/text
  messageBoxTextEl.innerText = text; 
  
  messageBoxShareBtn.style.display = 'none'; // Hide share button by default
  messageBoxOkBtn.innerText = 'Ok';
  
  if (type === 'achievement') {
    messageBoxTitleEl.innerHTML = `<i class="fas fa-trophy"></i> ${title}`;
    messageBoxShareBtn.style.display = 'inline-flex';
    messageBoxOkBtn.innerText = 'Continue';
    // Auto-hide after 4 seconds for achievements
    setTimeout(() => {
      if(messageBox.classList.contains('show')) {
        messageBox.classList.remove('show');
      }
    }, 4000);
  } else if (type === 'hint') {
    messageBoxTitleEl.innerHTML = `<i class="fas fa-lightbulb"></i> ${title}`;
  } else { // 'info' or any other type
    messageBoxTitleEl.innerHTML = `<i class="fas fa-info-circle"></i> ${title}`;
  }

  messageBox.classList.add('show'); 
}

// Event listener for the unified message box's OK button
$('#messageBoxOk').onclick = () => { 
  $('#messageBox').classList.remove('show'); 
};

// Achievements system
function addAchievement(key, text) { 
  if(!state.achievements.includes(key)) { 
    state.achievements.push(key); 
    saveState(); 
    renderAchievements(); 
    showMessageBox(key, text, 'achievement'); 
    
    // Special unlocks for certain achievements
    if(key === 'Level 5 Complete' && !state.unlocked.includes(6)) {
      unlockLevel(6);
    }
  } 
}

function unlockLevel(n) { 
  if(n <= NUM_LEVELS && !state.unlocked.includes(n)) { 
    state.unlocked.push(n); 
    saveState(); 
    renderLevels(); 
    
    // Achievement for unlocking levels
    if(n === 5) addAchievement('Halfway There', 'Unlocked the first 5 levels!');
    if(n === 10) addAchievement('Master Unlocker', 'Unlocked all levels!');
  } 
}

function completeLevel(n, score) { 
  if(!state.completed.includes(n)) { 
    state.completed.push(n); 
    state.scores[n] = score || 0; 
    
    // Save completion time
    state.bestTimes[n] = state.bestTimes[n] 
      ? Math.min(state.bestTimes[n], timerValue) 
      : timerValue;
    
    saveState(); 
    renderLevels(); 
    renderAchievements(); 
    
    // Different achievements based on performance
    if(score >= 90) {
      addAchievement(`Level ${n} Master`, `Completed level ${n} with ${score}% score!`);
    } else {
      addAchievement(`Level ${n} Complete`, `Completed level ${n} with ${score}% score`);
    }
    
    unlockLevel(n + 1); 
    updateScoreBar(); 
  } 
}

function updateScoreBar() { 
  const total = Object.values(state.scores).reduce((a, b) => a + b, 0); 
  const max = NUM_LEVELS * 100; 
  const pct = Math.round((total / max) * 100); 
  $('#scoreBar').style.width = pct + '%'; 
}

/* -------------------------- Render UI ------------------------------- */
function renderLevels() { 
  const container = $('#levelsList'); 
  container.innerHTML = ''; 
  
  for(let i = 1; i <= NUM_LEVELS; i++) {
    const btn = $create('div'); 
    btn.className = 'level-btn'; 
    
    const locked = !state.unlocked.includes(i);
    const completed = state.completed.includes(i);
    const score = state.scores[i] || 0;
    
    if(locked) btn.classList.add('locked');
    if(currentLevel === i) btn.classList.add('playing');
    
    // Calculate stars based on score
    let stars = 0;
    if(completed) {
      if(score >= 90) stars = 3;
      else if(score >= 70) stars = 2;
      else stars = 1;
    }
    
    btn.innerHTML = `
      <div>
        <div style='font-weight:700'>Level ${i}</div>
        <div class='meta'>${levels[i].meta || 'Puzzle'} ${levels[i].difficulty || ''}</div>
      </div>
      <div>
        ${locked ? `<span class="lock-icon"><i class="fas fa-lock"></i></span>` : ''}
        ${completed ? `<span class="stars">${'â˜…'.repeat(stars)}</span>` : ''}
        ${!locked && !completed ? '<span class="badge">NEW</span>' : ''}
      </div>
    `;
    
    btn.onclick = () => { 
      if(locked) { 
        shake(btn); 
        showMessageBox('Locked Level', `Level ${i} is locked. Complete previous levels to unlock!`, 'info');
      } else { 
        startLevel(i); 
      } 
    };
    
    container.appendChild(btn);
  }
}

function renderAchievements() { 
  const container = $('#achList'); 
  container.innerHTML = ''; 
  
  state.achievements.forEach(a => { 
    const el = $create('div'); 
    el.className = 'badge'; 
    el.innerHTML = `<i class="fas fa-trophy"></i> ${a}`; 
    container.appendChild(el); 
  }); 
}

function shake(el) { 
  el.animate([
    { transform: 'translateX(0)' },
    { transform: 'translateX(-6px)' },
    { transform: 'translateX(6px)' },
    { transform: 'translateX(0)' }
  ], { duration: 380 }); 
}

/* ------------------------ Level Implementations --------------------- */

// Level 1: Sequence Puzzle
function setupLevel1(container, done) {
  const sequenceColors = ['var(--accent)', 'var(--accent-2)', 'var(--accent-pink)', 'var(--accent-yellow)'];
  const sequenceNames = ['teal', 'cyan', 'pink', 'yellow'];
  const correctSequence = [0, 1, 2, 3]; // Indices of colors
  let userSequence = [];
  let clickable = true; // Prevents rapid clicks

  container.innerHTML = `
    <div style="text-align:center; padding:30px;">
      <h3 style="margin-bottom:15px; font-size:22px;">Sequence Puzzle</h3>
      <p style="color:var(--text-secondary); margin-bottom:25px;">Click the colors in the correct order!</p>
      <div class="grid" style="grid-template-columns: repeat(2, 1fr); max-width: 200px;">
        ${sequenceColors.map((color, idx) => `
          <div class="tile sequence-tile" data-index="${idx}" style="background:${color}; width:80px; height:80px;"></div>
        `).join('')}
      </div>
      <p id="sequenceStatus" style="margin-top:20px; font-weight:600; min-height:20px;"></p>
    </div>
  `;

  const tiles = container.querySelectorAll('.sequence-tile');
  const statusText = $('#sequenceStatus');

  tiles.forEach(tile => {
    tile.onclick = function() {
      if (!clickable) return;

      const index = parseInt(this.dataset.index);
      userSequence.push(index);

      // Add temporary highlight
      this.style.transform = 'scale(0.95)';
      this.style.opacity = '0.7';
      setTimeout(() => {
        this.style.transform = '';
        this.style.opacity = '';
      }, 150);

      if (userSequence.length === correctSequence.length) {
        clickable = false; // Disable clicks during evaluation
        let isCorrect = true;
        for (let i = 0; i < correctSequence.length; i++) {
          if (userSequence[i] !== correctSequence[i]) {
            isCorrect = false;
            break;
          }
        }

        if (isCorrect) {
          statusText.style.color = 'var(--success)';
          statusText.innerText = 'Correct Sequence!';
          tiles.forEach(t => t.classList.add('correct'));
          setTimeout(() => done(true), 1000); // Delay for visual feedback
        } else {
          statusText.style.color = 'var(--error)';
          statusText.innerText = 'Incorrect Sequence. Try again!';
          tiles.forEach(t => t.classList.add('incorrect'));
          shake(container);
          setTimeout(() => {
            tiles.forEach(t => t.classList.remove('incorrect'));
            userSequence = []; // Reset sequence
            clickable = true;
          }, 1000);
        }
      } else {
        // Provide hint for next expected color in the sequence
        // Only provide hint if the current click was incorrect
        if (index !== correctSequence[userSequence.length -1]) {
             statusText.style.color = 'var(--warning)';
             // Display the color name for the next expected color in sequence
             statusText.innerText = `Keep going! Next is ${sequenceNames[correctSequence[userSequence.length]]}.`;
        } else {
            statusText.innerText = ''; // Clear status for correct partial sequence
        }
      }
    };
  });
}

// Level 2: Memory Challenge
function setupLevel2(container, done) {
  const symbols = ['â­', 'ðŸš€', 'ðŸ’¡', 'ðŸ’Ž', 'âš™ï¸', 'âœ¨', 'âš¡', 'ðŸ”®'];
  let cards = [...symbols, ...symbols]; // Duplicates for pairs
  cards.sort(() => Math.random() - 0.5); // Shuffle cards

  let firstCard = null;
  let secondCard = null;
  let matchedPairs = 0;
  let lockBoard = false; // Prevents clicking during flip animation

  container.innerHTML = `
    <div style="text-align:center; padding:20px;">
      <h3 style="margin-bottom:15px; font-size:22px;">Memory Challenge</h3>
      <p style="color:var(--text-secondary); margin-bottom:25px;">Find all matching pairs!</p>
      <div class="grid memory-grid">
        ${cards.map((symbol, index) => `
          <div class="memory-card" data-symbol="${symbol}" data-index="${index}">
            <div class="card-inner">
              <div class="card-front"></div>
              <div class="card-back">${symbol}</div>
            </div>
          </div>
        `).join('')}
      </div>
      <p id="memoryStatus" style="margin-top:20px; font-weight:600; min-height:20px;"></p>
    </div>
  `;

  const cardElements = container.querySelectorAll('.memory-card');
  const statusText = $('#memoryStatus');

  function flipCard() {
    if (lockBoard) return;
    if (this === firstCard) return; // Prevent double clicking the same card

    this.classList.add('flipped');
    statusText.innerText = ''; // Clear previous message

    if (!firstCard) {
      firstCard = this;
      return;
    }

    secondCard = this;
    lockBoard = true;

    checkForMatch();
  }

  function checkForMatch() {
    const isMatch = firstCard.dataset.symbol === secondCard.dataset.symbol;

    if (isMatch) {
      disableCards();
    } else {
      unflipCards();
    }
  }

  function disableCards() {
    firstCard.classList.add('matched');
    secondCard.classList.add('matched');
    matchedPairs++;
    statusText.style.color = 'var(--success)';
    statusText.innerText = 'Match Found! Keep going.';
    resetBoard();

    if (matchedPairs === symbols.length) {
      statusText.style.color = 'var(--accent)';
      statusText.innerText = 'All pairs matched! Well done!';
      setTimeout(() => done(true), 1000);
    }
  }

  function unflipCards() {
    statusText.style.color = 'var(--error)';
    statusText.innerText = 'No match. Try again!';
    setTimeout(() => {
      firstCard.classList.remove('flipped');
      secondCard.classList.remove('flipped');
      shake(firstCard); // Shake both cards
      shake(secondCard);
      resetBoard();
    }, 1000);
  }

  function resetBoard() {
    [firstCard, secondCard, lockBoard] = [null, null, false];
  }

  cardElements.forEach(card => card.addEventListener('click', flipCard));
}


// Level 3: Slide Shift (3x3 Puzzle)
function setupLevel3(container, done) {
  const BOARD_SIZE = 3;
  let tiles = Array.from({ length: BOARD_SIZE * BOARD_SIZE - 1 }, (_, i) => i + 1); // 1 to 8
  tiles.push(0); // 0 represents the empty space

  // Helper to count inversions for solvability check
  function getInversions(arr) {
      let inversions = 0;
      const puzzleTiles = arr.filter(num => num !== 0); // Exclude the empty tile (0)
      for (let i = 0; i < puzzleTiles.length - 1; i++) {
          for (let j = i + 1; j < puzzleTiles.length; j++) {
              if (puzzleTiles[i] > puzzleTiles[j]) {
                  inversions++;
              }
          }
      }
      return inversions;
  }

  // Solvable shuffle function for 3x3 grid
  function shuffleSolvable(array) {
      let shuffledArray = [...array];
      let inversions;

      do {
          // Fisher-Yates shuffle
          for (let i = shuffledArray.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
          }
          inversions = getInversions(shuffledArray);
      } while (inversions % 2 !== 0); // For an N x N puzzle where N is odd (like 3x3),
                                     // it's solvable if the number of inversions is even.

      return shuffledArray;
  }

  tiles = shuffleSolvable(tiles); // Use the solvable shuffle

  container.innerHTML = `
    <div style="text-align:center; padding:20px;">
      <h3 style="margin-bottom:15px; font-size:22px;">Slide Shift</h3>
      <p style="color:var(--text-secondary); margin-bottom:25px;">Arrange the numbers in order (1-8), leaving the last spot empty!</p>
      <div class="grid slider-grid" id="sliderPuzzleGrid"></div>
      <p id="sliderStatus" style="margin-top:20px; font-weight:600; min-height:20px;"></p>
    </div>
  `;

  const gridElement = $('#sliderPuzzleGrid');
  const statusText = $('#sliderStatus');

  function renderTiles() {
    gridElement.innerHTML = '';
    tiles.forEach((number, index) => {
      const tile = $create('div', {
        className: `slider-piece ${number === 0 ? 'empty' : ''}`,
        innerText: number === 0 ? '' : number,
        // Set dataset properties directly
        dataset: { 
          index: index.toString(), // Convert to string for dataset
          number: number.toString() // Convert to string for dataset
        }
      });
      tile.addEventListener('click', () => moveTile(index));
      gridElement.appendChild(tile);
    });
  }

  function getEmptyTileIndex() {
    return tiles.indexOf(0);
  }

  function canMove(tileIndex, emptyIndex) {
    const rowTile = Math.floor(tileIndex / BOARD_SIZE);
    const colTile = tileIndex % BOARD_SIZE;
    const rowEmpty = Math.floor(emptyIndex / BOARD_SIZE);
    const colEmpty = emptyIndex % BOARD_SIZE;

    // Check if horizontally or vertically adjacent
    const isAdjacent = (Math.abs(rowTile - rowEmpty) === 1 && colTile === colEmpty) ||
                       (Math.abs(colTile - colEmpty) === 1 && rowTile === rowEmpty);
    return isAdjacent;
  }

  function moveTile(clickedIndex) {
    const emptyIndex = getEmptyTileIndex();

    if (canMove(clickedIndex, emptyIndex)) {
      // Swap tiles
      [tiles[clickedIndex], tiles[emptyIndex]] = [tiles[emptyIndex], tiles[clickedIndex]];
      renderTiles(); // Re-render the grid

      if (checkWin()) {
        statusText.style.color = 'var(--success)';
        statusText.innerText = 'Puzzle Solved! Amazing!';
        setTimeout(() => done(true), 1000);
      } else {
        statusText.innerText = ''; // Clear status if not won
      }
    } else {
      const clickedTile = gridElement.children[clickedIndex];
      if (clickedTile && !clickedTile.classList.contains('empty')) {
        shake(clickedTile);
        statusText.style.color = 'var(--error)';
        statusText.innerText = 'Cannot move that tile. Only adjacent tiles can move into the empty space.';
        setTimeout(() => statusText.innerText = '', 1500); // Clear message after a short delay
      }
    }
  }

  function checkWin() {
    // Check if numbers are in ascending order (1, 2, ..., 8) and 0 is at the end
    for (let i = 0; i < tiles.length - 1; i++) {
      if (tiles[i] !== i + 1) {
        return false;
      }
    }
    return tiles[tiles.length - 1] === 0; // Ensure empty tile is last
  }

  renderTiles(); // Initial render
}

// Level 4: Trace Echo
function setupLevel4(container, done) {
    const BOARD_SIZE = 3;
    const nodes = Array.from({ length: BOARD_SIZE * BOARD_SIZE }, (_, i) => i);
    let userPath = [];
    let isDrawing = false;
    let svg;
    let currentLine;

    container.innerHTML = `
        <div style="text-align:center; padding:20px;">
            <h3 style="margin-bottom:15px; font-size:22px;">Trace Echo</h3>
            <p style="color:var(--text-secondary); margin-bottom:25px;">Draw the correct pattern through the nodes!</p>
            <div class="grid trace-grid" id="tracePuzzleGrid" style="position:relative;">
                ${nodes.map((_, i) => `<div class="node" data-node-index="${i}"></div>`).join('')}
                <svg class="line-svg-container"></svg>
            </div>
            <p id="traceStatus" style="margin-top:20px; font-weight:600; min-height:20px;"></p>
            <div style="margin-top: 20px;">
                <button class="btn-ghost" id="resetTraceBtn"><i class="fas fa-undo"></i> Reset Path</button>
                <button class="primary" id="checkTraceBtn" style="margin-left: 10px;"><i class="fas fa-check"></i> Check Pattern</button>
            </div>
        </div>
    `;

    const gridElement = $('#tracePuzzleGrid');
    const statusText = $('#traceStatus');
    const resetBtn = $('#resetTraceBtn');
    const checkBtn = $('#checkTraceBtn');
    svg = gridElement.querySelector('svg');

    // Define the correct diagonal cross pattern (indices of nodes)
    // 0 1 2
    // 3 4 5
    // 6 7 8
    // Correct path: 0 -> 4 -> 8 (diagonal 1), then 2 -> 4 -> 6 (diagonal 2)
    // For simplicity, let's assume a continuous path for now, or two distinct paths.
    // The hint says "a diagonal cross starting from top-left to bottom-right, then top-right to bottom-left."
    // This implies 0-4-8 and 2-4-6. We'll require both.
    const correctPath1 = [0, 4, 8];
    const correctPath2 = [2, 4, 6]; // Note: 4 is common. We need to handle this.
    // Let's simplify and make it one continuous path for the user to draw: 0-4-8-6-2.
    // Or, more accurately to the hint: 0-4-8 then reset and 2-4-6. This implies two submissions.
    // For a single submission, let's make it 0-4-8-2-6.
    const CORRECT_PATTERN = [0, 4, 8, 2, 6];

    // Helper to get center coordinates of a node
    function getNodeCenter(node) {
        const rect = node.getBoundingClientRect();
        const gridRect = gridElement.getBoundingClientRect();
        return {
            x: (rect.left + rect.right) / 2 - gridRect.left,
            y: (rect.top + rect.bottom) / 2 - gridRect.top
        };
    }

    function startDrawing(e) {
        const targetNode = e.target.closest('.node');
        if (!targetNode) return;

        isDrawing = true;
        userPath = [parseInt(targetNode.dataset.nodeIndex)];
        targetNode.classList.add('active'); // Highlight the starting node

        // Start new SVG line
        const startPoint = getNodeCenter(targetNode);
        currentLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        currentLine.setAttribute('points', `${startPoint.x},${startPoint.y}`);
        currentLine.setAttribute('class', 'trace-line');
        svg.appendChild(currentLine);

        statusText.innerText = '';
    }

    function drawPath(e) {
        if (!isDrawing) return;

        const targetNode = e.target.closest('.node');
        if (targetNode) {
            const index = parseInt(targetNode.dataset.nodeIndex);
            if (userPath.length === 0 || userPath[userPath.length - 1] !== index) {
                // Only add if it's a new node or not the current one
                if (!userPath.includes(index) || (userPath.length > 0 && index === CORRECT_PATTERN[userPath.length])) {
                    userPath.push(index);
                    targetNode.classList.add('visited'); // Mark as visited
                    const point = getNodeCenter(targetNode);
                    let points = currentLine.getAttribute('points');
                    currentLine.setAttribute('points', `${points} ${point.x},${point.y}`);
                }
            }
        }
        // Update temporary line to mouse position if not on a node (visual feedback)
        const mouseX = e.clientX - gridElement.getBoundingClientRect().left;
        const mouseY = e.clientY - gridElement.getBoundingClientRect().top;
        if (currentLine && userPath.length > 0) {
            currentLine.setAttribute('points', `${currentLine.getAttribute('points').split(' ').slice(0, userPath.length).join(' ')} ${mouseX},${mouseY}`);
            currentLine.classList.add('temp');
        }
    }

    function stopDrawing() {
        if (!isDrawing) return;
        isDrawing = false;
        
        // Remove temporary line part
        if (currentLine) {
             const finalPoints = currentLine.getAttribute('points').split(' ').slice(0, userPath.length).join(' ');
             currentLine.setAttribute('points', finalPoints);
             currentLine.classList.remove('temp');
        }

        gridElement.querySelectorAll('.node').forEach(node => node.classList.remove('active'));
    }

    function checkPattern() {
        if (userPath.length === 0) {
            statusText.style.color = 'var(--warning)';
            statusText.innerText = 'Draw a pattern first!';
            return;
        }

        let isCorrect = true;
        if (userPath.length !== CORRECT_PATTERN.length) {
            isCorrect = false;
        } else {
            for (let i = 0; i < CORRECT_PATTERN.length; i++) {
                if (userPath[i] !== CORRECT_PATTERN[i]) {
                    isCorrect = false;
                    break;
                }
            }
        }

        if (isCorrect) {
            statusText.style.color = 'var(--success)';
            statusText.innerText = 'Pattern Correct! Level Complete!';
            gridElement.querySelectorAll('.node').forEach(node => {
                if (CORRECT_PATTERN.includes(parseInt(node.dataset.nodeIndex))) {
                    node.classList.add('correct');
                }
            });
            setTimeout(() => done(true), 1000);
        } else {
            statusText.style.color = 'var(--error)';
            statusText.innerText = 'Incorrect pattern. Try again!';
            shake(gridElement);
            setTimeout(resetPattern, 1500);
        }
    }

    function resetPattern() {
        userPath = [];
        svg.innerHTML = ''; // Clear SVG lines
        gridElement.querySelectorAll('.node').forEach(node => {
            node.classList.remove('active', 'visited', 'correct');
        });
        statusText.innerText = '';
    }

    gridElement.addEventListener('mousedown', startDrawing);
    gridElement.addEventListener('mousemove', drawPath);
    gridElement.addEventListener('mouseup', stopDrawing);
    gridElement.addEventListener('mouseleave', stopDrawing); // Important for when mouse leaves grid

    resetBtn.onclick = resetPattern;
    checkBtn.onclick = checkPattern;
}


// Level 5: Silent Maze
function setupLevel5(container, done) {
    // Maze definition: 0 = path, 1 = wall, 2 = player, 3 = exit
    const MAZE = [
        [0, 1, 0, 0, 0],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 0],
        [1, 1, 0, 1, 0],
        [0, 0, 0, 1, 3] // Exit at [4,4]
    ];
    let playerPos = { r: 0, c: 0 };
    const MAX_PINGS = 5;
    let pingsUsed = 0;

    container.innerHTML = `
        <div style="text-align:center; padding:20px;">
            <h3 style="margin-bottom:15px; font-size:22px;">Silent Maze</h3>
            <p style="color:var(--text-secondary); margin-bottom:25px;">Navigate to the exit. Use sonar pings wisely!</p>
            <div class="grid maze-grid" id="mazeGrid"></div>
            <div class="maze-info">Pings Left: <strong id="pingsLeft">${MAX_PINGS}</strong></div>
            <div class="maze-controls">
                <div class="direction-buttons">
                    <button class="btn-ghost up" data-direction="up"><i class="fas fa-arrow-up"></i></button>
                    <button class="btn-ghost left" data-direction="left"><i class="fas fa-arrow-left"></i></button>
                    <button class="btn-ghost center" id="pingBtn"><i class="fas fa-podcast"></i> Ping</button>
                    <button class="btn-ghost right" data-direction="right"><i class="fas fa-arrow-right"></i></button>
                    <button class="btn-ghost down" data-direction="down"><i class="fas fa-arrow-down"></i></button>
                </div>
            </div>
            <p id="mazeStatus" style="margin-top:20px; font-weight:600; min-height:20px;"></p>
        </div>
    `;

    const mazeGridElement = $('#mazeGrid');
    const pingsLeftEl = $('#pingsLeft');
    const mazeStatus = $('#mazeStatus');
    const pingBtn = $('#pingBtn');

    function renderMaze() {
        mazeGridElement.innerHTML = '';
        for (let r = 0; r < MAZE.length; r++) {
            for (let c = 0; c < MAZE[r].length; c++) {
                const cell = $create('div', {
                    className: 'maze-cell',
                    dataset: { r: r, c: c }
                });

                if (MAZE[r][c] === 1) { // Wall
                    cell.classList.add('wall');
                } else if (MAZE[r][c] === 3) { // Exit
                    cell.classList.add('exit');
                    cell.innerHTML = '<i class="fas fa-door-open"></i>';
                }

                // Initial player position
                if (r === playerPos.r && c === playerPos.c) {
                    cell.classList.add('player');
                    cell.innerHTML = '<i class="fas fa-person-walking"></i>';
                }
                
                // Keep visited paths marked if not pinged over
                if (cell.dataset.r == playerPos.r && cell.dataset.c == playerPos.c) {
                    // Current player position
                } else if (cell.classList.contains('visited-path') && !cell.classList.contains('pinged')) {
                    // Already visited path, keep the class
                } else {
                    cell.classList.remove('visited-path', 'pinged'); // Clean up from previous pings/moves
                }

                mazeGridElement.appendChild(cell);
            }
        }
    }

    function movePlayer(dr, dc) {
        const newR = playerPos.r + dr;
        const newC = playerPos.c + dc;

        if (newR >= 0 && newR < MAZE.length && newC >= 0 && newC < MAZE[0].length) {
            if (MAZE[newR][newC] !== 1) { // If not a wall
                const oldPlayerCell = mazeGridElement.querySelector(`.maze-cell[data-r="${playerPos.r}"][data-c="${playerPos.c}"]`);
                oldPlayerCell.classList.remove('player');
                oldPlayerCell.innerHTML = '';
                oldPlayerCell.classList.add('visited-path'); // Mark old path as visited

                playerPos = { r: newR, c: newC };
                renderMaze(); // Re-render to update player position

                if (MAZE[newR][newC] === 3) { // Reached exit
                    mazeStatus.style.color = 'var(--success)';
                    mazeStatus.innerText = 'Maze Solved! You found the exit!';
                    setTimeout(() => done(true), 1000);
                }
            } else {
                mazeStatus.style.color = 'var(--error)';
                mazeStatus.innerText = 'Ouch! That\'s a wall.';
                shake(mazeGridElement);
            }
        } else {
            mazeStatus.style.color = 'var(--error)';
            mazeStatus.innerText = 'You\'re at the edge!';
            shake(mazeGridElement);
        }
    }

    function usePing() {
        if (pingsUsed < MAX_PINGS) {
            pingsUsed++;
            pingsLeftEl.innerText = MAX_PINGS - pingsUsed;
            mazeStatus.style.color = 'var(--accent-2)';
            mazeStatus.innerText = 'Ping used! Revealing surroundings...';

            // Temporarily reveal cells around the player
            const revealRadius = 1; // Reveals 1 cell around player (3x3 area)
            for (let r = playerPos.r - revealRadius; r <= playerPos.r + revealRadius; r++) {
                for (let c = playerPos.c - revealRadius; c <= playerPos.c + revealRadius; c++) {
                    if (r >= 0 && r < MAZE.length && c >= 0 && c < MAZE[0].length) {
                        const cell = mazeGridElement.querySelector(`.maze-cell[data-r="${r}"][data-c="${c}"]`);
                        if (cell) {
                            cell.classList.add('pinged');
                            if (MAZE[r][c] === 1) { // If it's a wall
                                cell.innerHTML = '<i class="fas fa-times"></i>';
                            } else if (MAZE[r][c] === 3) { // If it's the exit
                                cell.innerHTML = '<i class="fas fa-door-open"></i>';
                            } else if (r === playerPos.r && c === playerPos.c) {
                                // Current player position, no change
                            } else {
                                cell.innerHTML = '<i class="fas fa-dot-circle"></i>'; // Path
                            }
                        }
                    }
                }
            }
            
            // Remove pinged status and temporary icons after a short delay
            setTimeout(() => {
                mazeGridElement.querySelectorAll('.maze-cell').forEach(cell => {
                    cell.classList.remove('pinged');
                    if (cell.classList.contains('player') || cell.classList.contains('exit')) {
                        // Keep player and exit icons
                    } else if (!cell.classList.contains('wall')) { // Only clear path icons
                         cell.innerHTML = ''; // Clear temporary icons
                    } else { // It's a wall, clear temporary icons
                         cell.innerHTML = '';
                    }
                });
            }, 1500); // Ping effect lasts 1.5 seconds

            if (pingsUsed >= MAX_PINGS) {
                pingBtn.disabled = true;
                mazeStatus.style.color = 'var(--warning)';
                mazeStatus.innerText = 'No pings left!';
            }
        } else {
            mazeStatus.style.color = 'var(--error)';
            mazeStatus.innerText = 'No pings left!';
        }
    }

    // Event listeners for direction buttons
    container.querySelectorAll('.direction-buttons button[data-direction]').forEach(btn => {
        btn.onclick = () => {
            const dir = btn.dataset.direction;
            mazeStatus.innerText = ''; // Clear status on move
            if (dir === 'up') movePlayer(-1, 0);
            else if (dir === 'down') movePlayer(1, 0);
            else if (dir === 'left') movePlayer(0, -1);
            else if (dir === 'right') movePlayer(0, 1);
        };
    });

    pingBtn.onclick = usePing;

    renderMaze();
}


// Level 6: Caesar Clue
function setupLevel6(container, done) {
    const ENCRYPTED_MESSAGE = "khoor zruog"; // "hello world" shifted by +3
    const CORRECT_SHIFT = 3; // Shift to decrypt to "hello world"

    function caesarCipher(text, shift, decrypt = false) {
        if (decrypt) shift = (26 - (shift % 26)) % 26; // Adjust shift for decryption
        let result = '';
        for (let i = 0; i < text.length; i++) {
            let char = text[i];
            if (char >= 'a' && char <= 'z') {
                let code = char.charCodeAt(0);
                char = String.fromCharCode(((code - 97 + shift) % 26) + 97);
            } else if (char >= 'A' && char <= 'Z') {
                let code = char.charCodeAt(0);
                char = String.fromCharCode(((code - 65 + shift) % 26) + 65);
            }
            result += char;
        }
        return result;
    }

    container.innerHTML = `
        <div class="cipher-container">
            <h3 style="margin-bottom:15px; font-size:22px;">Caesar Clue</h3>
            <p style="color:var(--text-secondary); margin-bottom:25px;">Decode the encrypted message. Shift value unknown.</p>
            <div class="encrypted-message" id="encryptedMessage">${ENCRYPTED_MESSAGE}</div>
            <div class="cipher-controls">
                <label for="shiftInput">Shift Value (0-25):</label>
                <input type="number" id="shiftInput" min="0" max="25" value="0">
                <button class="primary" id="decryptBtn"><i class="fas fa-key"></i> Decrypt</button>
            </div>
            <div class="decrypted-output" id="decryptedOutput"></div>
            <p id="cipherStatus" style="margin-top:20px; font-weight:600; min-height:20px;"></p>
        </div>
    `;

    const shiftInput = $('#shiftInput');
    const decryptBtn = $('#decryptBtn');
    const decryptedOutput = $('#decryptedOutput');
    const cipherStatus = $('#cipherStatus');

    function updateDecryptedText() {
        const shift = parseInt(shiftInput.value);
        if (isNaN(shift)) {
            decryptedOutput.innerText = '';
            cipherStatus.innerText = 'Please enter a valid shift number.';
            return;
        }
        const decrypted = caesarCipher(ENCRYPTED_MESSAGE, shift, true); // true for decryption
        decryptedOutput.innerText = decrypted;

        if (decrypted.toLowerCase() === 'hello world') {
            cipherStatus.style.color = 'var(--success)';
            cipherStatus.innerText = 'Message Decrypted! Level Complete!';
            decryptBtn.disabled = true;
            shiftInput.disabled = true;
            setTimeout(() => done(true), 1000);
        } else {
            cipherStatus.style.color = 'var(--text-secondary)';
            cipherStatus.innerText = 'Keep trying!';
        }
    }

    shiftInput.addEventListener('input', updateDecryptedText); // Decrypt on input change
    decryptBtn.onclick = updateDecryptedText;

    // Initial decryption on load
    updateDecryptedText();
}


// Level 7: Echo Math
function setupLevel7(container, done) {
    const TARGET_VALUE = 24; // Target value
    const AVAILABLE_NUMBERS = [2, 3, 4, 5, 8, 10]; // Numbers user can use

    container.innerHTML = `
        <div class="math-container">
            <h3 style="margin-bottom:15px; font-size:22px;">Echo Math</h3>
            <p style="color:var(--text-secondary); margin-bottom:25px;">Use the given numbers and basic operations to reach the target!</p>
            <div class="math-target">Target: <span id="mathTargetValue">${TARGET_VALUE}</span></div>
            <div class="math-numbers">
                ${AVAILABLE_NUMBERS.map(num => `<span class="math-number-tile">${num}</span>`).join('')}
            </div>
            <div class="math-input-group">
                <input type="text" id="mathExpressionInput" placeholder="e.g., (8 / 2) * 6">
                <button class="primary" id="calculateMathBtn"><i class="fas fa-calculator"></i> Calculate</button>
            </div>
            <div class="math-result" id="mathResult"></div>
            <p id="mathStatus" style="margin-top:20px; font-weight:600; min-height:20px;"></p>
            <p style="color:var(--muted); font-size:0.85em; margin-top:10px;">Allowed: numbers, +, -, *, /, (, )</p>
        </div>
    `;

    const mathExpressionInput = $('#mathExpressionInput');
    const calculateMathBtn = $('#calculateMathBtn');
    const mathResult = $('#mathResult');
    const mathStatus = $('#mathStatus');

    calculateMathBtn.onclick = () => {
        const expression = mathExpressionInput.value.trim();
        if (!expression) {
            mathStatus.style.color = 'var(--warning)';
            mathStatus.innerText = 'Please enter an expression.';
            return;
        }

        // Basic validation: ensure only allowed characters and numbers from the list are used
        // This regex ensures only digits, +, -, *, /, (, ), and spaces are present.
        if (!/^[0-9+\-*/()\s]+$/.test(expression)) {
            mathStatus.style.color = 'var(--error)';
            mathStatus.innerText = 'Invalid characters detected. Only numbers and basic operations (+, -, *, /, parentheses) are allowed.';
            shake(mathExpressionInput);
            return;
        }

        // Further validation: check if numbers used are from AVAILABLE_NUMBERS
        const numbersInExpression = expression.match(/\d+/g) || [];
        let allNumbersValid = true;
        for (const numStr of numbersInExpression) {
            const num = parseInt(numStr);
            if (!AVAILABLE_NUMBERS.includes(num)) {
                allNumbersValid = false;
                break;
            }
        }

        if (!allNumbersValid) {
            mathStatus.style.color = 'var(--error)';
            mathStatus.innerText = 'You can only use the numbers provided!';
            shake(mathExpressionInput);
            return;
        }

        try {
            const result = eval(expression); // Danger: eval() is powerful. Only use with strict input validation.
            mathResult.innerText = `Result: ${result}`;

            if (result === TARGET_VALUE) {
                mathStatus.style.color = 'var(--success)';
                mathStatus.innerText = 'Correct! Level Complete!';
                calculateMathBtn.disabled = true;
                mathExpressionInput.disabled = true;
                setTimeout(() => done(true), 1000);
            } else {
                mathStatus.style.color = 'var(--error)';
                mathStatus.innerText = `Incorrect. Expected ${TARGET_VALUE}.`;
                shake(mathExpressionInput);
            }
        } catch (e) {
            mathResult.innerText = '';
            mathStatus.style.color = 'var(--error)';
            mathStatus.innerText = 'Invalid expression. Check your syntax!';
            shake(mathExpressionInput);
        }
    };
}

// Level 8: Assemble Echo
function setupLevel8(container, done) {
    const PIECE_COUNT = 4; // Number of pieces (e.g., 2x2 grid)
    const TARGET_POSITIONS = [ // Define target top, left for each piece
        { top: 0, left: 0 }, { top: 0, left: 100 },
        { top: 100, left: 0 }, { top: 100, left: 100 }
    ];
    // Start pieces at random positions to be dragged
    const START_POSITIONS = [
        { top: 250, left: 50 }, { top: 250, left: 200 },
        { top: 350, left: 50 }, { top: 350, left: 200 }
    ];

    // Shuffle START_POSITIONS
    START_POSITIONS.sort(() => Math.random() - 0.5);

    let placedPieces = 0;
    let draggingPiece = null;
    let dragOffsetX, dragOffsetY;

    container.innerHTML = `
        <div class="assemble-container">
            <h3 style="margin-bottom:15px; font-size:22px;">Assemble Echo</h3>
            <p style="color:var(--text-secondary); margin-bottom:25px;">Drag the pieces to their correct target zones!</p>
            <div class="assemble-board" id="assembleBoard" style="width:200px; height:200px;">
                <!-- Target zones (fixed positions) -->
                ${TARGET_POSITIONS.map((pos, i) => `<div class="target-zone" data-target-id="${i}" style="grid-area: ${i+1}/${i+1};"></div>`).join('')}
            </div>
            <div id="puzzlePiecesContainer" style="position:relative; width:100%; height:400px; margin-top: 20px;">
                <!-- Puzzle pieces (positioned by JS) -->
            </div>
            <p id="assembleStatus" style="margin-top:20px; font-weight:600; min-height:20px;"></p>
        </div>
    `;

    const assembleBoard = $('#assembleBoard');
    const puzzlePiecesContainer = $('#puzzlePiecesContainer');
    const assembleStatus = $('#assembleStatus');

    // Create and position puzzle pieces
    for (let i = 0; i < PIECE_COUNT; i++) {
        const piece = $create('div', {
            className: 'puzzle-piece',
            innerText: String.fromCharCode(65 + i), // A, B, C, D
            dataset: { pieceId: i, targetId: i } // Each piece has a matching target
        });
        piece.style.top = `${START_POSITIONS[i].top}px`;
        piece.style.left = `${START_POSITIONS[i].left}px`;
        puzzlePiecesContainer.appendChild(piece);

        piece.addEventListener('mousedown', startDrag);
        piece.addEventListener('touchstart', startDrag, { passive: false }); // For touch events
    }

    function startDrag(e) {
        if (this.classList.contains('placed')) return; // Cannot drag placed pieces

        e.preventDefault(); // Prevent default touch behavior (scrolling)
        draggingPiece = this;
        draggingPiece.style.zIndex = '100'; // Bring to front

        const rect = draggingPiece.getBoundingClientRect();
        const containerRect = puzzlePiecesContainer.getBoundingClientRect();

        if (e.type === 'mousedown') {
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
        } else if (e.type === 'touchstart') {
            const touch = e.touches[0];
            dragOffsetX = touch.clientX - rect.left;
            dragOffsetY = touch.clientY - rect.top;
        }
        
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchmove', drag, { passive: false });
        document.addEventListener('touchend', endDrag);
    }

    function drag(e) {
        if (!draggingPiece) return;
        e.preventDefault(); // Prevent default touch behavior (scrolling)

        let clientX, clientY;
        if (e.type === 'mousemove') {
            clientX = e.clientX;
            clientY = e.clientY;
        } else if (e.type === 'touchmove') {
            const touch = e.touches[0];
            if (!touch) return;
            clientX = touch.clientX;
            clientY = touch.clientY;
        } else {
            return;
        }

        const containerRect = puzzlePiecesContainer.getBoundingClientRect();
        let newX = clientX - containerRect.left - dragOffsetX;
        let newY = clientY - containerRect.top - dragOffsetY;

        // Keep piece within container bounds
        newX = Math.max(0, Math.min(newX, containerRect.width - draggingPiece.offsetWidth));
        newY = Math.max(0, Math.min(newY, containerRect.height - draggingPiece.offsetHeight));

        draggingPiece.style.left = `${newX}px`;
        draggingPiece.style.top = `${newY}px`;
    }

    function endDrag(e) {
        if (!draggingPiece) return;

        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('touchmove', drag);
        document.removeEventListener('touchend', endDrag);

        const pieceId = parseInt(draggingPiece.dataset.pieceId);
        const targetId = parseInt(draggingPiece.dataset.targetId); // This piece's correct target

        const pieceRect = draggingPiece.getBoundingClientRect();
        const boardRect = assembleBoard.getBoundingClientRect();

        let droppedCorrectly = false;
        // Check if the piece is over its designated target zone
        const targetZone = assembleBoard.querySelector(`.target-zone[data-target-id="${targetId}"]`);
        if (targetZone) {
            const targetRect = targetZone.getBoundingClientRect();

            // Simple overlap check
            if (pieceRect.left < targetRect.right &&
                pieceRect.right > targetRect.left &&
                pieceRect.top < targetRect.bottom &&
                pieceRect.bottom > targetRect.top)
            {
                // Snap to target position
                draggingPiece.style.left = `${targetRect.left - boardRect.left}px`;
                draggingPiece.style.top = `${targetRect.top - boardRect.top}px`;
                draggingPiece.classList.add('placed');
                placedPieces++;
                droppedCorrectly = true;
                assembleStatus.style.color = 'var(--success)';
                assembleStatus.innerText = `Piece ${draggingPiece.innerText} placed correctly!`;
            }
        }
        
        if (!droppedCorrectly) {
            assembleStatus.style.color = 'var(--error)';
            assembleStatus.innerText = 'Incorrect placement. Try again!';
            shake(draggingPiece);
            // Optionally, return piece to original starting position if desired
            // For now, leave it where dropped if not correct, but remove placed state
            draggingPiece.classList.remove('placed');
        }

        draggingPiece.style.zIndex = '10'; // Reset z-index
        draggingPiece = null;

        if (placedPieces === PIECE_COUNT) {
            assembleStatus.style.color = 'var(--accent)';
            assembleStatus.innerText = 'All pieces assembled! Level Complete!';
            setTimeout(() => done(true), 1000);
        }
    }
}


// Level 9: Pulse
function setupLevel9(container, done) {
    let animationFrameId;
    let rotation = 0; // degrees
    let speed = 2; // degrees per frame
    const GREEN_ZONE_START = -30; // degrees from top (0)
    const GREEN_ZONE_END = 30; // degrees from top (0)
    let tries = 0;
    const MAX_TRIES = 5; // For demonstration, limit tries

    container.innerHTML = `
        <div class="pulse-container">
            <h3 style="margin-bottom:15px; font-size:22px;">Pulse</h3>
            <p style="color:var(--text-secondary); margin-bottom:25px;">Click when the indicator is in the green zone!</p>
            <div class="pulse-circle-container">
                <div class="pulse-indicator" id="pulseIndicator"></div>
                <div class="pulse-zone" style="transform: rotateZ(${GREEN_ZONE_START}deg);"></div>
            </div>
            <p id="pulseInfo" class="pulse-info">Tries: 0 / ${MAX_TRIES}</p>
            <button class="primary" id="pulseClickBtn"><i class="fas fa-hand-pointer"></i> Click!</button>
            <p id="pulseStatus" style="margin-top:20px; font-weight:600; min-height:20px;"></p>
        </div>
    `;

    const pulseIndicator = $('#pulseIndicator');
    const pulseClickBtn = $('#pulseClickBtn');
    const pulseStatus = $('#pulseStatus');
    const pulseInfo = $('#pulseInfo');

    function animatePulse() {
        rotation = (rotation + speed) % 360;
        pulseIndicator.style.transform = `rotateZ(${rotation}deg) translateY(-125px)`; // Adjust translateY to match radius
        animationFrameId = requestAnimationFrame(animatePulse);
    }

    function stopPulse() {
        cancelAnimationFrame(animationFrameId);
        pulseClickBtn.disabled = true;

        let currentAngle = rotation;
        // Normalize angle to be within -180 to 180 for easier zone checking if needed
        if (currentAngle > 180) currentAngle -= 360;

        // Check if indicator is within the green zone (top section)
        const inGreenZone = (currentAngle >= GREEN_ZONE_START && currentAngle <= GREEN_ZONE_END);

        tries++;
        pulseInfo.innerText = `Tries: ${tries} / ${MAX_TRIES}`;

        if (inGreenZone) {
            pulseStatus.style.color = 'var(--success)';
            pulseStatus.innerText = 'Perfect Timing! Level Complete!';
            setTimeout(() => done(true), 1000);
        } else {
            pulseStatus.style.color = 'var(--error)';
            pulseStatus.innerText = 'Missed! Try again.';
            shake(pulseIndicator);
            speed += 0.5; // Increase speed on miss (as per hint)

            if (tries >= MAX_TRIES) {
                pulseStatus.style.color = 'var(--error)';
                pulseStatus.innerText = 'Out of tries! Level Failed.';
                setTimeout(() => done(false), 1500); // Fail level if out of tries
            } else {
                pulseClickBtn.disabled = false;
                animatePulse(); // Restart animation for next try
            }
        }
    }

    pulseClickBtn.onclick = stopPulse;
    animatePulse();
}


// Level 10: Full Echo (Combination of Level 6 and Level 7)
function setupLevel10(container, done) {
    const ENCRYPTED_PART = "wkh ilqdo dqvzhu lv brxu qdph"; // "the final answer is your name" shifted by +3
    const CORRECT_CIPHER_SHIFT = 3; // Shift to decrypt to "the final answer is your name"
    const MATH_QUESTION = "What is 4 * 6?"; // Hidden in the decrypted message
    const MATH_ANSWER = 24;

    function caesarCipher(text, shift, decrypt = false) {
        if (decrypt) shift = (26 - (shift % 26)) % 26;
        let result = '';
        for (let i = 0; i < text.length; i++) {
            let char = text[i];
            if (char >= 'a' && char <= 'z') {
                let code = char.charCodeAt(0);
                char = String.fromCharCode(((code - 97 + shift) % 26) + 97);
            } else if (char >= 'A' && char <= 'Z') {
                let code = char.charCodeAt(0);
                char = String.fromCharCode(((code - 65 + shift) % 26) + 65);
            }
            result += char;
        }
        return result;
    }

    container.innerHTML = `
        <div class="cipher-container" style="padding-bottom:10px;">
            <h3 style="margin-bottom:15px; font-size:22px;">Grand Finale: Cipher</h3>
            <p style="color:var(--text-secondary); margin-bottom:15px;">Part 1: Decode this message. It holds a clue!</p>
            <div class="encrypted-message" id="lvl10EncryptedMessage">${ENCRYPTED_PART}</div>
            <div class="cipher-controls">
                <label for="lvl10ShiftInput">Shift Value (0-25):</label>
                <input type="number" id="lvl10ShiftInput" min="0" max="25" value="0">
                <button class="primary" id="lvl10DecryptBtn"><i class="fas fa-key"></i> Decrypt</button>
            </div>
            <div class="decrypted-output" id="lvl10DecryptedOutput"></div>
            <p id="lvl10CipherStatus" style="margin-top:10px; font-weight:600; min-height:20px;"></p>
        </div>

        <div class="math-container" style="margin-top:30px; border-top:1px solid var(--border); padding-top:20px;">
            <h3 style="margin-bottom:15px; font-size:22px;">Grand Finale: Math</h3>
            <p style="color:var(--text-secondary); margin-bottom:15px;">Part 2: Solve the puzzle revealed by the decrypted message.</p>
            <div id="mathQuestion" style="font-size:1.5em; font-weight:bold; color:var(--accent); margin-bottom:20px; opacity:0.3;">
                <i class="fas fa-lock"></i> Decrypt message first
            </div>
            <div class="math-input-group">
                <input type="text" id="lvl10MathAnswerInput" placeholder="Your numerical answer">
                <button class="primary" id="lvl10SubmitMathBtn" disabled><i class="fas fa-check"></i> Submit Answer</button>
            </div>
            <p id="lvl10MathStatus" style="margin-top:10px; font-weight:600; min-height:20px;"></p>
        </div>
    `;

    const lvl10ShiftInput = $('#lvl10ShiftInput');
    const lvl10DecryptBtn = $('#lvl10DecryptBtn');
    const lvl10DecryptedOutput = $('#lvl10DecryptedOutput');
    const lvl10CipherStatus = $('#lvl10CipherStatus');
    const mathQuestionEl = $('#mathQuestion');
    const lvl10MathAnswerInput = $('#lvl10MathAnswerInput');
    const lvl10SubmitMathBtn = $('#lvl10SubmitMathBtn');
    const lvl10MathStatus = $('#lvl10MathStatus');

    let cipherPartSolved = false;

    function handleCipherDecryption() {
        const shift = parseInt(lvl10ShiftInput.value);
        if (isNaN(shift)) {
            lvl10CipherStatus.innerText = 'Please enter a valid shift number.';
            return;
        }
        const decrypted = caesarCipher(ENCRYPTED_PART, shift, true);
        lvl10DecryptedOutput.innerText = decrypted;

        if (decrypted.toLowerCase() === 'the final answer is your name') { // Our specific target
            lvl10CipherStatus.style.color = 'var(--success)';
            lvl10CipherStatus.innerText = 'Cipher Decrypted! Proceed to Part 2.';
            lvl10DecryptBtn.disabled = true;
            lvl10ShiftInput.disabled = true;
            cipherPartSolved = true;
            
            // Reveal math question and enable input
            mathQuestionEl.style.opacity = '1';
            mathQuestionEl.innerHTML = `Solve this: <span style="color:var(--accent-2);">${MATH_QUESTION}</span>`;
            lvl10SubmitMathBtn.disabled = false;
            lvl10MathAnswerInput.disabled = false;
        } else {
            lvl10CipherStatus.style.color = 'var(--text-secondary)';
            lvl10CipherStatus.innerText = 'Keep trying!';
            cipherPartSolved = false;
            mathQuestionEl.style.opacity = '0.3';
            mathQuestionEl.innerHTML = `<i class="fas fa-lock"></i> Decrypt message first`;
            lvl10SubmitMathBtn.disabled = true;
            lvl10MathAnswerInput.disabled = true;
        }
    }

    function handleSubmitMathAnswer() {
        if (!cipherPartSolved) {
            lvl10MathStatus.style.color = 'var(--warning)';
            lvl10MathStatus.innerText = 'Complete the cipher part first!';
            return;
        }

        const userAnswer = parseInt(lvl10MathAnswerInput.value.trim());
        if (isNaN(userAnswer)) {
            lvl10MathStatus.style.color = 'var(--warning)';
            lvl10MathStatus.innerText = 'Please enter a numerical answer.';
            return;
        }

        if (userAnswer === MATH_ANSWER) {
            lvl10MathStatus.style.color = 'var(--success)';
            lvl10MathStatus.innerText = 'Correct! Grand Finale Complete!';
            lvl10SubmitMathBtn.disabled = true;
            lvl10MathAnswerInput.disabled = true;
            setTimeout(() => done(true), 1000);
        } else {
            lvl10MathStatus.style.color = 'var(--error)';
            lvl10MathStatus.innerText = 'Incorrect answer. Try again!';
            shake(lvl10MathAnswerInput);
        }
    }

    lvl10ShiftInput.addEventListener('input', handleCipherDecryption);
    lvl10DecryptBtn.onclick = handleCipherDecryption;
    lvl10SubmitMathBtn.onclick = handleSubmitMathAnswer;
    
    // Initial state
    lvl10MathAnswerInput.disabled = true;
    lvl10SubmitMathBtn.disabled = true;
    handleCipherDecryption(); // Run once to set initial state
}


/* ------------------------ Level runner ----------------------------- */
function startLevel(n) {
  currentLevel = n; 
  $('#curLevel').innerText = n; 
  document.querySelectorAll('.level-btn').forEach(x => x.classList.remove('playing')); 
  
  const list = document.querySelectorAll('.level-btn'); 
  if(list[n - 1]) list[n - 1].classList.add('playing'); 
  
  const lvl = levels[n]; 
  $('#levelTitle').innerText = `Level ${n} â€” ${lvl.title}`; 
  $('#levelDesc').innerText = lvl.desc; 
  $('#statusText').innerText = 'Playing'; 
  $('#unlocked').innerText = 'Solving this level will unlock new content'; 
  
  const area = $('#gameArea'); 
  area.innerHTML = ''; 
  
  // Start game timer
  timerValue = 0;
  if(gameTimer) clearInterval(gameTimer);
  gameTimer = setInterval(() => {
    timerValue++;
    const mins = Math.floor(timerValue / 60);
    const secs = timerValue % 60;
    $('#timerDisplay').innerText = `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  }, 1000);
  
  // Create timer display (re-render as part of controls)
  const timerElHtml = `<div class="stat-box" id="timerDisplay">
    <i class="fas fa-clock"></i> Time: 0:00
  </div>`;
  
  // Create hint counter (re-render as part of controls)
  const hintCounterHtml = `<div class="stat-box" id="hintCounter">
    <i class="fas fa-lightbulb"></i> Hints: ${state.hintsUsed[n] || 0}
  </div>`;
  
  // Game controls
  const controls = $create('div');
  controls.className = 'game-controls';
  controls.innerHTML = `
    <div class="game-stats">
      ${timerElHtml}
      ${hintCounterHtml}
      <div class="stat-box">
        <i class="fas fa-star"></i> Level: ${levels[n].difficulty}
      </div>
    </div>
    <div>
      <button class="btn-ghost" id="hintBtn">
        <i class="fas fa-lightbulb"></i> Show Hint
      </button>
    </div>
  `;
  
  area.appendChild(controls);
  
  // Puzzle container
  const puzzleWrap = $create('div');
  puzzleWrap.style.width = '100%';
  puzzleWrap.style.display = 'flex';
  puzzleWrap.style.justifyContent = 'center';
  puzzleWrap.style.alignItems = 'center';
  puzzleWrap.style.flexDirection = 'column';
  puzzleWrap.style.padding = '20px';
  puzzleWrap.style.flexGrow = '1'; // Allow puzzle area to grow

  area.appendChild(puzzleWrap);
  
  // Choose the correct level setup function
  let setupFunction;
  switch (n) {
    case 1: setupFunction = setupLevel1; break;
    case 2: setupFunction = setupLevel2; break;
    case 3: setupFunction = setupLevel3; break;
    case 4: setupFunction = setupLevel4; break;
    case 5: setupFunction = setupLevel5; break;
    case 6: setupFunction = setupLevel6; break;
    case 7: setupFunction = setupLevel7; break;
    case 8: setupFunction = setupLevel8; break;
    case 9: setupFunction = setupLevel9; break;
    case 10: setupFunction = setupLevel10; break;
    default: setupFunction = (container, done) => setupLevelPlaceholder(container, done, n); break;
  }

  // Setup the level
  setupFunction(puzzleWrap, (success) => {
    // Stop timer
    clearInterval(gameTimer);
    
    // Calculate score
    const timeScore = Math.max(10, 100 - Math.floor(timerValue / 2));
    const penalty = (state.hintsUsed[n] || 0) * 15;
    const finalScore = percentClamp(timeScore - penalty);
    
    if(success) { 
      $('#statusText').innerText = 'Completed!'; 
      completeLevel(n, finalScore); 
      state.hintsUsed[n] = state.hintsUsed[n] || 0; 
      saveState(); 
      
      // Show completion message
      puzzleWrap.innerHTML = `
        <div style="text-align:center; padding:30px;">
          <h3 style="font-size:32px; color:var(--success); margin-bottom:20px;">
            <i class="fas fa-check-circle"></i> Level Complete!
          </h3>
          <div style="display:flex; justify-content:center; gap:30px; margin:30px 0;">
            <div class="stat-box" style="font-size:18px;">
              <i class="fas fa-star"></i> Score: ${finalScore}%
            </div>
            <div class="stat-box" style="font-size:18px;">
              <i class="fas fa-clock"></i> Time: ${timerValue}s
            </div>
          </div>
          <p>You earned ${finalScore >= 90 ? '3' : finalScore >= 70 ? '2' : '1'} stars for this level!</p>
          <div style="margin-top:30px;">
            <button class="primary" id="nextLevelBtn">
              <i class="fas fa-arrow-right"></i> Next Level
            </button>
          </div>
        </div>
      `;
      
      // Add event listener for next level button
      puzzleWrap.querySelector('#nextLevelBtn').onclick = () => {
        if(n < NUM_LEVELS) {
          startLevel(n + 1);
        } else {
            showMessageBox('Congratulations!', 'You have completed all available levels. More challenges coming soon!', 'info');
            // Option to restart or go to welcome screen
            $('#gameArea').innerHTML = `
                <div class="welcome-screen">
                    <h1>You've Mastered All Puzzles!</h1>
                    <p>Congratulations on completing all the EchoPuzzles Pro challenges. Stay tuned for new levels!</p>
                    <div class="hero-btns">
                        <button class="primary" id="restartGameBtn">
                            <i class="fas fa-redo"></i> Restart Game
                        </button>
                    </div>
                </div>
            `;
            $('#restartGameBtn').onclick = () => {
                // Clear all game state and restart
                localStorage.removeItem(STORAGE_KEY);
                state = loadState(); 
                init();
                startLevel(1); // Start over from level 1
            };
        }
      };
    } 
    else { 
      $('#statusText').innerText = 'Failed'; 
      // If failed, give option to retry
      puzzleWrap.innerHTML = `
        <div style="text-align:center; padding:30px;">
          <h3 style="font-size:32px; color:var(--error); margin-bottom:20px;">
            <i class="fas fa-times-circle"></i> Level Failed!
          </h3>
          <p>Don't give up! Try again to conquer this challenge.</p>
          <div style="margin-top:30px;">
            <button class="primary" id="retryLevelBtn">
              <i class="fas fa-redo"></i> Retry Level
            </button>
          </div>
        </div>
      `;
      puzzleWrap.querySelector('#retryLevelBtn').onclick = () => startLevel(n);
    }
  });
  
  // Hint button functionality
  $('#hintBtn').onclick = () => {
    state.hintsUsed[n] = (state.hintsUsed[n] || 0) + 1;
    saveState();
    // Update hint counter display
    $('#hintCounter').innerHTML = `<i class="fas fa-lightbulb"></i> Hints: ${state.hintsUsed[n]}`;
    
    // Show hint using the unified message box
    showMessageBox(`Hint for Level ${n}`, levels[n].hint, 'hint');
  };
}

/* ------------------------ Initialization ---------------------------- */
function init() { 
  renderLevels(); 
  renderAchievements(); 
  updateScoreBar(); 
  
  if(!state.unlocked.includes(1)) unlockLevel(1); 
  
  $('#startBtn').onclick = () => { 
    startLevel(1); 
    addAchievement('First Puzzle', 'Started your puzzle journey!');
  };
  
  // Set initial progress
  updateScoreBar();
}

init();

/* ------------------------ Extra helpers ----------------------------- */
function $all(sel) { return Array.from(document.querySelectorAll(sel)); }

// Removed the setTimeout for simulating progress, as it interferes with live gameplay.
// state.completed = [1, 2, 3];
// state.scores = {1: 85, 2: 90, 3: 75};
// state.achievements = ['Welcome!', 'Level 1 Complete', 'Level 2 Complete', 'Level 3 Complete', 'Halfway There'];
// state.unlocked = [1, 2, 3, 4, 5];
// saveState();
// renderLevels();
// renderAchievements();
// updateScoreBar();
</script>
</body>
</html>
